<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.42-DEV" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Ivan V &nbsp; </title>

  
  <link rel="stylesheet" href="https://bege13mot.github.io/css/poole.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/highlight/sunburst.css">
  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://bege13mot.github.io/touch-icon-144-precomposed.png">
  <link href="/icon/fox.png" rel="icon">

  
  
  
  <link href="https://bege13mot.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Ivan V &nbsp; " />

  <meta name="description" content="">
  <meta name="keywords" content="">
  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
            
        <img src="/icon/fox.png" alt="avatar" title="">    
      
      <h1></h1>
      
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/">Ivan V's Blog</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/about/">About</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/post/">Posts</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/tags/">Tags</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/categories/">Categories</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/Bege13mot"><img src="/icon/github.svg" class="fa"></img></a>
      <a href="https://www.goodreads.com/user/show/5520080-ivan"><img src="/icon/goodreads.svg" class="fa"></img></a>
      <a href="mailto:bege13mot@gmail.com"><img src="/icon/mail.svg" class="fa"></img></a>
      <a href="https://ru.linkedin.com/in/voronchihin"><img src="/icon/linkedin.svg" class="fa"></img></a>      
      <a href="https://bege13mot.github.io/index.xml" type="application/rss+xml"><img src="/icon/rss.svg" class="fa"></img></a>
      </li>
    </ul>

    

  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://bege13mot.github.io/post/pandemic/">Пандемия: всемирная история смертельных вирусов, Соня Шах</a>
      </h1>
      <span class="post-date">Oct 28, 2017 &nbsp;  &nbsp; <a href="https://bege13mot.github.io/post/pandemic/#disqus_thread">Comments</a>
      </span>
      <p>
            
      <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
      
      
      Tag:      
      <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/non-fiction">non-fiction</a>
      </p>
      
      

<p><img src="/img/2017/pandemic.jpg" alt="image" /></p>

<p>Один из моих недостатков - сравнивание книг с фильмами. В данном случае фильм-катастрофa как нельзя лучше описывает происходящее в книге. Начитается все с истории возникновения холеры, одного и самых смертоносных заболеваний. Затем описывается как холера поражала целые города в 19 веке, и что за ужасные условия были в этих городах. Следом автор быстренько пробегается по проблемам современного здравоохранения - коррупция, медлительности, сфокусированная на европейских болезнях (лекарства от холеры и малярии слишком дешевы). Рассматривает ближайшее будущее - где благодаря изменению климата, повсеместному использованию антибиотиков, скученности домашних животных, будут появляться новы болезни, опаснее прежних. Ну и в конце кратенько об истории сосуществования людей и вирусов, например, сейчас люди не производят сиаловую кислоту, а раньше производили. И походу все те кто производил, вымерли.</p>

<p>Вот такая веселая книга. Но интересная конечно.</p>

<h4 id="заметки">Заметки:</h4>

<ul>
<li><p>В наше время холера считается болезнью бедных стран, но так было не всегда. В XIX веке холера поражала самые развитые и процветающие города мира, кося бедных и богатых без разбора – от Парижа и Лондона до Нью-Йорка и Нового Орлеана. В 1836 году она лишила жизни Карла X в Италии, в 1849 году – президента Джеймса Полка в Новом Орлеане, в 1893 году – композитора Петра Ильича Чайковского в Санкт-Петербурге. Число заболевших в XIX веке составило сотни миллионов, и больше половины из них скончались.</p></li>

<li><p>Первой из новых инфекционных болезней, поразивших зажиточный Запад и разрушивших представление о «постинфекционной» эре, стал вирус иммунодефицита человека (ВИЧ), появившийся в начале 1980-х. Хотя никто не знал, откуда он взялся и как его лечить, многие не сомневались, что медицина с этим выскочкой вот-вот справится. Изобретут лекарства, наладят вакцинацию. &hellip; Следом объявились другие инфекционные патогены, такие же неуязвимые для хорошо отработанных, привычных мер профилактики и сдерживания: вирус Западного Нила, атипичная пневмония, лихорадка Эбола и новые разновидности птичьего гриппа, поражающие человека. «Восставшие из небытия» микробы научились противостоять воздействию когда-то эффективных лекарств, и теперь мы имеем лекарственно-устойчивый туберкулез, возрождающуюся малярию и все ту же холеру. Всего с 1940 по 2004 год более 300 инфекционных болезней появились заново или возродились в местах и человеческих популяциях, в которых они не встречались раньше.</p></li>

<li><p>Пандемию холероподобного заболевания предрекают многие специалисты. В ходе опроса, проведенного эпидемиологом Ларри Бриллиантом, 90 % его коллег прогнозировали в пределах ближайших двух поколений пандемию, способную поразить до 1 млрд человек, убить до 165 млн и вызвать глобальный экономический спад, убытки от которого достигнут 3 трлн долларов. Пока ни одна из двух пандемий, вызванных новоявленными патогенами – ВИЧ и свиным гриппом, не сравнилась по смертоносности и скорости распространения с холерой. ВИЧ, несомненно, смертельно опасен, но распространяется медленно; свиной грипп в 2009 году распространялся стремительно и широко, но лишил жизни только 0,005 % заболевших.</p></li>

<li><p>Хотя микроорганизмы, обладающие потенциалом перехода в человеческие, водятся в самых разных средах, большинство из них, точно так же, как холерный вибрион или вирус атипичной пневмонии, становятся патогенами в организмах других животных. Более 60 % известных патогенов впервые появились у окружающих нас пернатых и хвостатых, в том числе домашних животных – как скота, так и комнатных питомцев. Из них основная масса – свыше 70 % – обязана происхождением диким видам.</p></li>

<li><p>Огромная доля человеческих патогенов поступает от других приматов, которые – притом что составляют лишь 0,5 % всех позвоночных – наградили нас 20 % самых тяжких болезней (в том числе ВИЧ и малярией). По той же причине многие человеческие патогены ведут свою историю от зарождения сельского хозяйства примерно 10 000 лет назад, когда люди начали одомашнивать другие виды и вступили с ними в продолжительный тесный контакт. От коров мы получили корь и туберкулез, от свиней – коклюш, от уток – грипп.</p></li>

<li><p>У бессмертия, несомненно, есть свои выгоды, но есть и существенные издержки. Одна из них заключается в том, что бессмертный вид очень быстро разрастается до исчерпания необходимых ему ресурсов окружающей среды. И тогда он становится уязвимым для таких бедствий, как голод и пандемии, которые могут уничтожить его одним махом, убив всех представителей разом.</p></li>

<li><p>Помимо прочего, в геномах имеются свидетельства о некой пандемии, случившейся далеко в прошлом. Она поразила гоминид (из которых до наших времен дожил только Homo sapiens) около 2 млн лет назад. Указания на нее содержатся в гене, который контролирует выработку вещества под названием сиаловая кислота. На протяжении 300 000 лет – один миг по эволюционным меркам – все производящие эту кислоту особи вымирали или не могли продолжить род, оставляя будущее за теми, кто не вырабатывал сиаловую кислоту, поскольку их вариант гена отключал ее производство. Что могло вызвать такую резкую и быструю перемену? Ученый, обнаруживший утрату этого гена, специалист по сиаловой кислоте Аджит Варки, подозревает пандемию.</p></li>

<li><p>Как предполагает специалист по истории болезней Уильям Макнилл, именно такие высоколокализованные особенности иммунного поведения обусловили появление в Индии кастовой системы, строго ограничивающей контакты между кастами и вынуждающей проходить сложные обряды очищения, если контакт все же состоялся. Отчасти, как считает Макнилл, это может объясняться наличием у каждой группы определенного иммунного поведения, направленного против привычных для нее патогенов, и потребностью в системе, стоящей на страже межгрупповых границ.</p></li>
</ul>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://bege13mot.github.io/post/unix-book/">﻿Операционная система UNIX, Андрей Робачевский</a>
      </h1>
      <span class="post-date">Sep 1, 2017 &nbsp;  &nbsp; <a href="https://bege13mot.github.io/post/unix-book/#disqus_thread">Comments</a>
      </span>
      <p>
            
      <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
      
      
      Tag:      
      <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/theory">theory</a>
      </p>
      
      

<p><img src="/img/2017/unix-book.jpg" alt="image" /></p>

<p>Книга о Unix 1997 года. При это не скажешь что она особенно устарело. Описываются базовые, по-прежнему актуальные, вещи - структура файловой системы, типы процессов, сигналов, подсистема управления процессами, сеть. И все это на русском, очень понятно, с объяснениями и разжёвыванием.</p>

<p>Хороший учебник.</p>

<h4 id="заметки">Заметки:</h4>

<ul>
<li><p>В UNIX существуют 6 типов файлов:</p>

<ul>
<li>обычный файл</li>
<li>каталог</li>
<li>специальный файл устройства</li>
<li>именованный канал или FIFO</li>
<li>символическая связь</li>
<li>сокет</li>
</ul></li>

<li><p>Обычно программой называют совокупность файлов, будь то набор исходных текстов, объектных файлов или собственно выполняемый файл. Для того чтобы программа могла быть запущена на выполнение, операционная система сначала должна создать окружение или среду выполнения задачи, куда относятся ресурсы памяти, возможность доступа к устройствам ввода/вывода и различным системным ресурсам, включая услуги ядра.
Это окружение (среда выполнения задачи) получило название процесса. Мы можем представить процесс как совокупность данных ядра системы, необходимых для описания образа программы в памяти и управления ее выполнением. Мы можем также представить процесс как программу в стадии ее выполнения, поскольку все выполняющиеся программы представлены в UNIX в виде процессов. Процесс состоит из инструкций, выполняемых процессором, данных и информации о выполняемой задаче, такой как размещенная память, открытые файлы и статус процесса.</p></li>

<li><p>Процесс в UNIX создается системным вызовом fork(). Процесс, сделавший вызов fork() называется родительским, а вновь созданный процесс — дочерним. Новый процесс является точной копией породившего его процесса. Как это ни удивительно, но новый процесс имеет те же инструкции и данные, что и его родитель. Более того, выполнение родительского и дочернего процесса начнется с одной и той же инструкции, следующей за вызовом fork(). Единственно, чем они различаются — это идентификатором процесса PID. Каждый процесс имеет одного родителя, но может иметь несколько дочерних процессов.
Для запуска задачи, т.е. для загрузки новой программы, процесс должен выполнить системный вызов exec(). При этом новый процесс не порождается, а исполняемый код процесса полностью замещается кодом запускаемой программы. Тем не менее окружение новой программы во многом сохраняется, в частности сохраняются значения переменных окружения, назначения стандартных потоков ввода/вывода, вывода сообщений об ошибках, а также приоритет процесса.
В UNIX запуск на выполнение новой программы часто связан с порождением нового процесса, таким образом сначала процесс выполняет вызов fork(), порождая дочерний процесс, который затем выполняет exec(), полностью замещаясь новой программой.</p></li>

<li><p>Все процессы в UNIX создаются посредством вызова fork(). Запуск на выполнение новых задач осуществляется либо по схеме fork-and-exec, либо с помощью exec(). &ldquo;Прародителем&rdquo; всех процессов является процесс init(1М), называемый также распределителем процессов. Если построить граф &ldquo;родственных отношений&rdquo; между процессами, то получится дерево, корнем которого является init(1M).</p></li>

<li><p>По умолчанию команда kill() посылает сигнал с номером 15 — SIGTERM, действие по умолчанию для которого — завершение выполнения процесса, получившего сигнал.
Иногда процесс продолжает существовать и после отправления сигнала SIGTERM. В этом случае можно применить более жесткое средство — послать процессу сигнал SIGKILL с номером (9), — поскольку этот сигнал нельзя ни перехватить, ни игнорировать</p></li>

<li><p>Каждый активный процесс в UNIX имеет уникальный идентификатор процесса, PID. Запуская скрипт, вы порождаете в системе процесс с уникальным PID. Значение PID сохраняется в переменной $$. Эту переменную удобно использовать в названиях временных файлов, поскольку их имена будут уникальными</p></li>

<li><p>Напомним, что сигналы SIGKILL и SIGSTOP невозможно ни игнорировать, ни перехватить. Сигнал SIGKILL является силовым методом завершения выполнения &ldquo;непослушного&rdquo; процесса, а от работоспособности SIGSTOP зависит функционирование системы управления заданиями.</p></li>

<li><p>Смысл виртуальной памяти заключается в том, что каждый процесс выполняется в собственном виртуальном адресном пространстве. Виртуальное адресное пространство — настоящий рай для процесса. Во-первых, у процесса создается ощущение исключительности — ведь все адресное пространство принадлежит только ему. Во-вторых, он больше не ограничен объемом физической памяти — виртуальная память может значительно превышать физическую. В результате процессы становятся изолированными друг от друга и не имеют возможности (даже при желании) &ldquo;хозяйничать&rdquo; в адресном пространстве соседа. Физическая память распределяется максимально эффективно — она не зависит от распределения виртуальной памяти отдельного процесса.</p></li>

<li><p>Можно сказать, что каждый процесс в операционной системе UNIX выполняется на собственной виртуальной вычислительной машине, где все ресурсы принадлежат исключительно данному процессу. Подсистема управления памятью обеспечивает такую иллюзию в отношении физической памяти.</p></li>

<li><p>Существуют всего три события, при которых выполнение процесса переходит в режим ядра — аппаратные прерывания, особые ситуации и системные вызовы. Во всех случаях ядро UNIX получает управление и вызывает соответствующую системную процедуру для обработки события. Перед вызовом ядро сохраняет состояние прерванного процесса в системном стеке. После завершения обработки, состояние процесса восстанавливается и процесс возвращается в исходный режим выполнения. Чаще всего это режим задачи, но если, например, прерывание возникло, когда процесс уже находился в режиме ядра, после обработки события он останется в этом режиме.</p></li>

<li><p>Для синхронизации процессов, а точнее, для синхронизации доступа нескольких процессов к разделяемым ресурсам, используются семафоры. Являясь одной из форм IPC, семафоры не предназначены для обмена большими объемами данных, как в случае FIFO или очередей сообщений. Вместо этого, они выполняют функцию, полностью соответствующую своему названию — разрешать или запрещать процессу использование того или иного разделяемого ресурса.</p></li>

<li><p>Если говорить о производительности IPC, то наиболее быстрым способом передачи данных между неродственными процессами является разделяемая память. Разделяемая память является частью адресного пространства для каждого из взаимодействующих процессов, поэтому чтение и запись в эту область неотличимы, например, от чтения и записи в область собственных данных процесса. Однако при использовании разделяемой памяти необходимо обеспечить синхронизацию процессов.</p></li>

<li><p>Индексный дескриптор, или inode, содержит информацию о файле, необходимую для обработки данных, т.е. метаданные файла. Каждый файл ассоциирован с одним inode, хотя может иметь несколько имен в файловой системе, каждое из которых указывает на один и тот же inode.Основные поля дискового inode следующие:</p>

<ul>
<li>Тип файла, дополнительные атрибуты выполнения и права доступа.</li>
<li>Число ссылок на файл, т.е. количество имен, которые имеет файл в файловой системе.</li>
<li>Идентификаторы владельца-пользователя и владельца- группы.</li>
<li>Cтарший и младший номера устройства.</li>
<li>Время последнего доступа к файлу.</li>
<li>Время последней модификации.</li>
<li>Время последней модификации inode (кроме модификации полей di_atime, di_mtime).</li>
<li>Массив адресов дисковых блоков хранения данных.</li>
</ul></li>

<li><p>Поскольку характеристики периферийных устройств значительно различаются, то UNIX использует два основных типа драйверов — символьные и блочные. Как следует из названия, драйверы первого типа обеспечивают обмен сравнительно небольшими объемами данных с устройством, что имеет место при работе, например, с терминалами или принтерами. Драйверы второго типа производят передачу данных блоками, что характерно для дисковых носителей данных. Эти типы драйверов входят в традиционную подсистему ввода/вывода и присутствуют во всех версиях UNIX.</p></li>

<li><p>Как уже обсуждалось, старший номер устройства адресует драйвер, в то время как младший номер интерпретируется самим драйвером и может использоваться для различных целей. Например, используя различные младшие номера, процесс может получить доступ к разным разделам жесткого диска, обслуживаемого одним драйвером.</p></li>
</ul>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://bege13mot.github.io/post/high-networking/">High-Performance Browser Networking, Ilya Grigorik</a>
      </h1>
      <span class="post-date">Aug 25, 2017 &nbsp;  &nbsp; <a href="https://bege13mot.github.io/post/high-networking/#disqus_thread">Comments</a>
      </span>
      <p>
            
      <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
      
      
      Tag:      
      <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/tech">tech</a>
      </p>
      
      

<p><img src="/img/2017/high-networking.jpg" alt="image" /></p>

<p>Не верится, что такая книга может быть <a href="https://hpbn.co/">бесплатной</a>. Детальный разбор всех нюансов работы с сетью для веб-приложений. Начиная с самых низов и азов. Обязательно буду перечитывать.</p>

<h4 id="notes">Notes:</h4>

<ul>
<li><p>“Good developers know how things work. Great developers know why things work.” We all resonate with this adage. We want to be that person who understands and can explain the underpinning of the systems we depend on.</p></li>

<li><p>All TCP connections begin with a three-way handshake: SYN, SYN ACK, ACK</p></li>

<li><p>The delay imposed by the three-way handshake makes new TCP connections expensive to create, and is one of the big reasons why connection reuse is a critical optimization for any application running over TCP.</p></li>

<li><p>So why is slow-start an important factor to keep in mind when we are building applications for the browser? Well, HTTP and many other application protocols run over TCP, and no matter the available bandwidth, every TCP connection must go through the slow-start phase—we cannot use the full capacity of the link immediately! Instead, we start with a small congestion window and double it for every roundtrip—i.e., exponential growth.</p></li>

<li><p>In addition to regulating the transmission rate of new connections, TCP also implements a slow-start restart (SSR) mechanism, which resets the congestion window of a connection after it has been idle for a defined period of time. The rationale is simple: the network conditions may have changed while the connection has been idle, and to avoid congestion, the window is reset to a “safe” default.
Not surprisingly, SSR can have a significant impact on performance of long-lived TCP connections that may idle for bursts of time—e.g., HTTP keepalive connections. As a result, it is recommended to disable SSR on the server.</p></li>

<li><p>As a result, the rate with which a TCP connection can transfer data in modern high-speed networks is often limited by the roundtrip time between the receiver and sender. Further, while bandwidth continues to increase, latency is bounded by the speed of light and is already within a small constant factor of its maximum value. In most cases, latency, not bandwidth, is the bottleneck for TCP—e.g.</p></li>

<li><p>Tuning Server Configuration</p>

<ul>
<li>As a starting point, prior to tuning any specific values for each buffer and timeout variable in TCP, of which there are dozens, you are much better off simply upgrading your hosts to their latest system versions. TCP best practices and underlying algorithms that govern its performance continue to evolve, and most of these changes are only available only in the latest kernels. In short, keep your servers up to date to ensure the optimal interaction between the sender’s and receiver’s TCP stacks.</li>
<li>On the surface, upgrading server kernel versions seems like trivial advice. However, in practice, it is often met with significant resistance: many existing servers are tuned for specific kernel versions, and system administrators are reluctant to perform the upgrade. To be fair, every upgrade brings its risks, but to get the best TCP performance, it is also likely the single best investment you can make. With the latest kernel in place, it is good practice to ensure that your server is configured to use the following best practices:

<ul>
<li>Increasing TCP’s Initial Congestion Window - A larger starting congestion window allows TCP transfers more data in the first roundtrip and significantly accelerates the window growth—an especially critical optimization for bursty and short-lived connections.</li>
<li>Slow-Start Restart - Disabling slow-start after idle will improve performance of long-lived TCP connections, which transfer data in bursts.</li>
<li>Window Scaling (RFC 1323) - Enabling window scaling increases the maximum receive window size and allows high-latency connections to achieve better throughput.</li>
<li>TCP Fast Open - Allows application data to be sent in the initial SYN packet in certain situations. TFO is a new optimization, which requires support both on client and server; investigate if your application can make use of it.</li>
</ul></li>
<li>The combination of the preceding settings and the latest kernel will enable the best performance—lower latency and higher throughput—for individual TCP connections.
Depending on your application, you may also need to tune other TCP settings on the server to optimize for high connection rates, memory consumption, or similar criteria. However, these configuration settings are dependent on the platform, application, and hardware—consult your platform documentation as required.</li>
</ul></li>

<li><p>Performance Checklist for TCP:</p>

<ul>
<li>Upgrade server kernel to latest version (Linux: 3.2+).</li>
<li>Ensure that cwnd size is set to 10.</li>
<li>Disable slow-start after idle.</li>
<li>Ensure that window scaling is enabled.</li>
<li>Eliminate redundant data transfers.</li>
<li>Compress transferred data.</li>
<li>Position servers closer to the user to reduce roundtrip times.</li>
<li>Reuse established TCP connections whenever possible.</li>
</ul></li>

<li><p>Terminating the connection closer to the user is an optimization that will help decrease latency for your users in all cases, but once again, no bit is faster than a bit not sent—send fewer bits. Enabling TLS session caching and stateless resumption will allow you to eliminate an entire roundtrip for repeat visitors.
Session identifiers, on which TLS session caching relies, were introduced in SSL 2.0 and have wide support among most clients and servers. However, if you are configuring SSL/TLS on your server, do not assume that session support will be on by default. In fact, it is more common to have it off on most servers by default—but you know better! You should double-check and verify your configuration:</p>

<ul>
<li>Servers with multiple processes or workers should use a shared session cache.</li>
<li>Size of the shared session cache should be tuned to your levels of traffic.</li>
<li>A session timeout period should be provided.</li>
<li>In a multiserver setup, routing the same client IP, or the same TLS session ID, to the same server is one way to provide good session cache utilization.</li>
<li>Where “sticky” load balancing is not an option, a shared cache should be used between different servers to provide good session cache utilization.</li>
<li>Check and monitor your SSL/TLS session cache statistics for best performance.</li>
<li>Alternatively, if the client and server both support session tickets, then all session data will be stored on the client, and none of these steps are required—much, much simpler! However, because session tickets are a relatively new extension in TLS, not all clients support it. In practice, and for best results, you should enable both: session tickets will be used for clients that support them, and session identifiers as a fallback for older clients. These mechanisms are not exclusive, and they work together well.</li>
</ul></li>

<li><p>Performance Checklist for TLS:</p>

<ul>
<li>Get best performance from TCP; see Optimizing for TCP.</li>
<li>Upgrade TLS libraries to latest release, and (re)build servers against them.</li>
<li>Enable and configure session caching and stateless resumption</li>
<li>Monitor your session caching hit rates and adjust configuration accordingly.</li>
<li>Terminate TLS sessions closer to the user to minimize roundtrip latencies.</li>
<li>Configure your TLS record size to fit into a single TCP segment.</li>
<li>Ensure that your certificate chain does not overflow the initial congestion window.</li>
<li>Remove unnecessary certificates from your chain; minimize the depth.</li>
<li>Disable TLS compression on your server.</li>
<li>Configure SNI support on your server.</li>
<li>Configure OCSP stapling on your server.</li>
<li>Append HTTP Strict Transport Security header.</li>
</ul></li>

<li><p>The parsing of the HTML document is what constructs the Document Object Model (DOM). In parallel, there is an oft-forgotten cousin, the CSS Object Model (CSSOM), which is constructed from the specified stylesheet rules and resources. The two are then combined to create the “render tree,” at which point the browser has enough information to perform a layout and paint something to the screen. So far, so good.
However, this is where we must, unfortunately, introduce our favorite friend and foe: JavaScript. Script execution can issue a synchronous doc.write and block DOM parsing and construction. Similarly, scripts can query for a computed style of any object, which means that JavaScript can also block on CSS. Consequently, the construction of DOM and CSSOM objects is frequently intertwined: DOM construction cannot proceed until JavaScript is executed, and JavaScript execution cannot proceed until CSSOM is available.
The performance of your application, especially the first load and the “time to render” depends directly on how this dependency graph between markup, stylesheets, and JavaScript is resolved. Incidentally, recall the popular “styles at the top, scripts at the bottom” best practice? Now you know why! Rendering and script execution are blocked on stylesheets; get the CSS down to the user as quickly as you can.</p></li>

<li><p>WebPageTest.org is an open-source project and a free web service that provides a system for testing the performance of web pages from multiple locations around the world: the browser runs within a virtual machine and can be configured and scripted with a variety of connection and browser-oriented settings. Following the test, the results are then available through a web interface, which makes WebPageTest an indispensable power tool in your web performance toolkit.</p></li>

<li><p>There are four techniques employed by most browsers:</p>

<ul>
<li>Resource pre-fetching and prioritization - Document, CSS, and JavaScript parsers may communicate extra information to the network stack to indicate the relative priority of each resource: blocking resources required for first rendering are given high priority, while low-priority requests may be temporarily held back in a queue.</li>
<li>DNS pre-resolve -  Likely hostnames are pre-resolved ahead of time to avoid DNS latency on a future HTTP request. A pre-resolve may be triggered through learned navigation history, a user action such as hovering over a link, or other signals on the page.</li>
<li>TCP pre-connect - Following a DNS resolution, the browser may speculatively open the TCP connection in an anticipation of an HTTP request. If it guesses right, it can eliminate another full roundtrip (TCP handshake) of network latency.</li>
<li>Page pre-rendering - Some browsers allow you to hint the likely next destination and can pre-render the entire page in a hidden tab, such that it can be instantly swapped in when the user initiates the navigation.</li>
</ul></li>

<li><p>Similarly, speaking of good reference books, Steve Souders’ High Performance Web Sites offers great advice in the form of 14 rules, half of which are networking optimizations:</p>

<ul>
<li>Reduce DNS lookups</li>
<li>Every hostname resolution requires a network roundtrip, imposing latency on the request and blocking the request while the lookup is in progress.</li>
<li>Make fewer HTTP requests</li>
<li>No request is faster than a request not made: eliminate unnecessary resources on your pages.</li>
<li>Use a Content Delivery Network</li>
<li>Locating the data geographically closer to the client can significantly reduce the network latency of every TCP connection and improve throughput.</li>
<li>Add an Expires header and configure ETags</li>
<li>Relevant resources should be cached to avoid re-requesting the same bytes on each and every page. An Expires header can be used to specify the cache lifetime of the object, allowing it to be retrieved directly from the user’s cache and eliminating the HTTP request entirely. ETags and Last-Modified headers provide an efficient cache revalidation mechanism—effectively a fingerprint or a timestamp of the last update.</li>
<li>Gzip assets</li>
<li>All text-based assets should be compressed with Gzip when transferred between the client and the server. On average, Gzip will reduce the file size by 60–80%, which makes it one of the simpler (configuration flag on the server) and high-benefit optimizations you can do.</li>
<li>Avoid HTTP redirects</li>
<li>HTTP redirects can be extremely costly, especially when they redirect the client to a different hostname, which results in additional DNS lookup, TCP connection latency, and so on.</li>
</ul></li>
</ul>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://bege13mot.github.io/post/code-book/">﻿Книга шифров. Тайная история шифров и их расшифровки, Саймон Сингх</a>
      </h1>
      <span class="post-date">Jul 5, 2017 &nbsp;  &nbsp; <a href="https://bege13mot.github.io/post/code-book/#disqus_thread">Comments</a>
      </span>
      <p>
            
      <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
      
      
      Tag:      
      <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/non-fiction">non-fiction</a>
      </p>
      
      

<p><img src="/img/2017/code-book.jpg" alt="image" /></p>

<p>Чудесная книга, пожалуй лучший нон-фикшен, что прочитал в этом году. Рассказана история возникновения и развития криптографии, людей что за ней стояли. Например, только отсюда узнал, что первым &ldquo;энигму&rdquo; взломал поляк Реевский, а не Тьюринг. А основа знаменитого алгоритма RSA придуман после вечеринки.</p>

<p>Самое обидное, последние главы посвящены ассиметричному шифрованию и приватности частной переписки. А в 1999 году, когда книга и была написана, не было биткойна (2008 год) и Сноудена (2013 год). Сколько еще хороших глав можно было бы прочитать. В общем, жду продолжения.</p>

<h4 id="заметки">Заметки:</h4>

<ul>
<li><p>Секретная переписка, осуществляемая путем сокрытия имеющегося сообщения, носит название стеганография, которое происходит из греческих слов steganos — «покрытый» и graphein — «писать». &hellip; Стеганография также включает в себя применение невидимых чернил. Еще в первом веке н. э. Плиний-старший показал, как млечный сок некоторых растений может использоваться в качестве таких чернил. После высыхания надпись, сделанная этими чернилами, не видна, но при несильном нагреве она приобретает коричневый цвет. Многие органические жидкости ведут себя похожим образом: при нагреве, из-за того, что в них содержится большое количество углерода, они темнеют. И это не составляет секрета для нынешних шпионов, которые, в случае если у них исчерпались симпатические чернила, используют для этой цели собственную мочу.</p></li>

<li><p>Цель криптографии состоит не в том, чтобы скрыть наличие сообщения, а в том, чтобы скрыть его смысл, — процесс, известный как шифрование. Чтобы сделать сообщение непонятным, оно зашифровывается по определенному правилу, которое заранее оговаривается между отправителем сообщения и его получателем. Так что адресат, получив сообщение, может применить к нему правило шифрования в обратном порядке, после чего его смысл станет понятным. Преимущество криптографии состоит в том, что если противник перехватит зашифрованное сообщение, то прочитать его ему не удастся. Восстановить исходное сообщение из зашифрованного текста, не зная правила шифрования, может оказаться для противника сложной, а то и вообще невыполнимой задачей.</p></li>

<li><p>Хотя криптография и стеганография являются независимыми, но для обеспечения максимальной секретности, чтобы и зашифровать, и скрыть сообщение, можно пользоваться обеими. К примеру, во время Второй мировой войны стала популярной микроточка, которая является одним из видов стеганографии. Германские агенты в Латинской Америке фотографическим способом сжимали страницу текста в точку диаметром менее 1 миллиметра, а затем прикрепляли эту микроточку поверх обычной точки в конце предложения в на первый взгляд совершенно безобидном письме.</p></li>

<li><p>В отличие от алгоритма, важность ключа является основополагающим принципом криптографии. Он был сформулирован в 1883 году голландским лингвистом Огюстом Керкхоффом в книге «Военная криптография» («La Cryptographie militaire»); правило Керкхоффа гласит: «Стойкость криптосистемы не должна зависеть от стойкости криптоалгоритма. Она зависит только от стойкости ключа». Помимо того, что ключ должен храниться в секрете, стойкая система шифрования должна также обладать широким набором возможных ключей. Например, если для зашифровывания сообщения отправитель применяет шифр сдвига Цезаря, то такое шифрование является сравнительно слабым, так как существует всего 25 возможных ключей.</p></li>

<li><p>Такая простота и одновременно стойкость означали, что на протяжении первого тысячелетия н. э. в искусстве тайнописи преобладал шифр замены. Шифровальщики разработали надежную систему обеспечения связи, поэтому никакой необходимости в дальнейшем развитии и не возникало. Бремя легло только на тех дешифровальщиков, кто старался раскрыть шифр замены. Существовал ли какой-нибудь способ разгадать зашифрованное сообщение? Многие ученые того времени полагали, что из-за гигантского количества возможных ключей шифр замены раскрыть невозможно, и в течение столетий казалось, что они были правы. Однако дешифровальщики в конце концов отыскали короткий путь взамен перебора всех возможных ключей. Вместо того чтобы тратить миллионы лет на взлом шифра, с помощью этого упрощенного метода сообщение можно было прочесть за нескольких минут. Прорыв произошел на Востоке, но для этого потребовался союз лингвистики, статистики и религиозного рвения.</p></li>

<li><p>Благодаря достижениям Чарльза Бэббиджа и Фридриха Касиски шифр Виженера более не был безопасным. Теперь, когда криптоаналитики вновь обрели контроль в коммуникационной войне, криптографы не могли гарантировать секретности. Хотя они и пытались разрабатывать новые шифры, но во второй половине девятнадцатого столетия не появилось ничего существенного, и профессиональные криптографы были в смятении. Однако как раз в это же самое время у широкой публики появился огромный интерес к шифрам.
Развитие телеграфа, которое вызвало рост интереса коммерческого характера к криптографии, привело также и к формированию общественного интереса к ней.</p></li>

<li><p>Одноразовый шифрблокнот полезен только тем, кому нужна сверхнадежная связь и кто может позволить себе заплатить огромную цену за создание и надежное распределение ключей. Например, безопасность телефонной «горячей линии» между президентами России и Америки обеспечивается посредством использования одноразового шифрблокнота.
Практические недостатки теоретически совершенного одноразового шифрблокнота означали, что идею Моборна никогда не удастся применить в разгаре сражения. По окончании Первой мировой войны и всех криптографических неудач продолжался поиск практичной системы, которую можно было бы применить в следующем конфликте.</p></li>

<li><p>В результате совершенного Реевским прорыва передаваемые немцами сообщения больше не представляли секрета. Польша не находилась в состоянии войны с Германией, но существовала угроза вторжениями то, что «Энигма» была покорена, стало для нее огромным облегчением. Если поляки смогут выяснить, что замышляют в отношении них немецкие генералы, то это давало им возможность защитить себя. Судьба Польши зависела от Реевского, и он не подвел свою страну. Атака Реевского на «Энигму» является одним из по-истине величайших достижений криптоанализа.</p></li>

<li><p>В значительной степени позаимствовав концепцию универсальной машины Алана Тьюринга, Ньюмен спроектировал машину, которая была способна сама настраиваться на решение различных задач — то, что сегодня мы назвали бы программируемым компьютером. Реализация конструкции Ньюмена считалась технически невозможной, так что руководство Блечли даже не стало рассматривать проект. По счастью, Томми Флауэрс, инженер, принимавший участие в обсуждении проекта Ньюмена, решил проигнорировать скептицизм Блечли и приступил к созданию такой машины. В исследовательском центре Управления почт и телеграфа в Доллис Хилл, в Северном Лондоне, Флауэрс взял чертежи Ньюмена и потратил десять месяцев, чтобы создать на его основе машину «Колосс», которую 8 декабря 1943 года передал в Блечли-Парк. Машина состояла из 1500 электронных ламп, которые действовали значительно быстрее медлительных электромеханических релейных переключателей, используемых в «бомбах». Но гораздо важнее скорости «Колосса» являлось то, что эту машину можно было программировать. Благодаря этому-то «Колосс» и стал предшественником современных цифровых ЭВМ.</p></li>

<li><p>Уитфилд Диффи — один из криптографов-энтузиастов своего поколения. Внешний вид его поражает и создает отчасти противоречивый образ. Его безупречный костюм отражает тот факт, что большую часть 90-х годов он трудился в одной из американских компьютерных корпораций — ныне официально его должность звучит как «Заслуженный инженер компании Сан Микросистеме». В то же время его длинные, до плеч, волосы и белая бородка говорят о том, что сердце его принадлежит 60-м. Он проводит массу времени за компьютером, но выглядит так, словно столь же комфортно он чувствовал бы себя и в ашраме Бомбея.</p></li>

<li><p>Но Диффи и Хеллман не интересовались двусторонними функциями. Они обратили свое внимание на односторонние функции. Как следует из названия, одностороннюю функцию легко вычислить в прямом направлении, но очень сложно в обратном. Другими словами, двусторонние функции обратимы, а односторонние функции необратимы. И опять-таки самый простой способ показать, что такое односторонняя функция, — это рассмотреть ее на примере повседневной деятельности. Смешивание желтой и синей красок для получения зеленой краски является односторонней функцией, поскольку краски смешать несложно, но вот разделить их после этого снова на исходные невозможно. Односторонней функцией также будет разбивание яйца: разбить яйцо легко, но вернуть его в исходное состояние уже невозможно. Из-за этого односторонние функции иногда называются функциями Шалтай-Болтая. Модулярная арифметика, иногда в школе называемая арифметикой, оперирующей с абсолютными значениями чисел, является разделом математики, который богат односторонними функциями. В модулярной арифметике математики имею дело с циклически замкнутыми конечными группами чисел, подобно числам на циферблате часов.</p></li>

<li><p>Озарение снизошло на Хеллмана глубокой ночью, так что, когда он закончил расчеты, было уже слишком поздно, чтобы звонить Диффи и Мерклю. Ему пришлось ждать утра, когда он смог продемонстрировать свое открытие двум единственным в мире людям, кто верил в возможность решения проблемы распределения ключей. «Осенило меня, — говорит Хеллман, — но в разработке принципов участвовали мы все вместе». Диффи сразу же осознал всю мощь открытия Хеллмана: «Марти объяснил свою систему обмена ключами во всей ее простоте. Когда я слушал его, то понял, что ка-кое-то время эта идея крутилась и у меня в голове, но так и не выкристаллизовалась».</p></li>

<li><p>Я попросил Рона, чтобы он убрал мое имя из статьи, — вспоминает Адлеман. — Я сказал ему, что это его открытие, а не мое. Но Рон отказался, и в результате завязался спор. Мы порешили, что я отправлюсь домой, поразмышляю над этим ночь и скажу, чего бы мне хотелось. На следующий день я вернулся и предложил Рону, чтобы он поставил меня третьим автором. Как мне сейчас вспоминается, тогда я думал, что эта статья будет самой неинтересной из всех, которые я когда-либо писал». Вряд ли Адлеман мог ошибиться сильнее. Алгоритм, получивший название RSA (Ривест, Шамир, Адлеман), а не ARS, стал важнейшим шифром в современной криптографии.</p></li>

<li><p>Одним из самых известных случаев связан с Мартином Лютером Кингом-младшим, чьи телефонные разговоры неправомерно прослушивались в течение нескольких лет. Так, в 1963 году ФБР получило информацию на Кинга путем прослушивания телефонных переговоров и предоставило ее сенатору Джеймсу Истланду, чтобы помочь ему в дебатах по законопроекту о гражданских правах. По большей части ФБР собирало подробности о личной жизни Кинга, которые использовались для его дискредитации. Записи о Кинге, рассказывающем скабрезные истории, были посланы его жене и воспроизведены перед президентом Джонсоном. А после того, как Кингу была присуждена Нобелевская премия мира, обескураживающие подробности о жизни Кинга были переданы во все организации, которые, как считалось, поддержали его награждение.</p></li>

<li><p>Очевидно, что спор ведется между двумя лагерями: борцы за гражданские права и компании выступают за криптостойкое шифрование, в то время как сотрудники правоприменяющих органов высказываются в пользу строгих ограничений. В целом, общественное мнение, на которое повлияли благожелательные средства массовой информации и пара голливудских фильмов, поддерживает альянс, выступающий за шифрование. В начале 1998 года в фильме «Меркурий в опасности» была рассказана история о новом шифре АНБ, который, как полагали, взломать было невозможно, но который был непреднамеренно раскрыт девятилетним, умственно неполноценным, хотя и гениальным в отдельных областях мальчиком. Агент АНБ, чью роль сыграл Алек Болдуин, намеревается убить ребенка, воспринимаемого им в качестве угрозы национальной безопасности. По счастью у мальчика есть защитник, Брюс Уиллис, который спасает его. В том же 1998 году Голливуд выпустил фильм «Враг государства», где речь шла о заговоре АНБ с целью убийства политика, ратующего за стойкое шифрование. Политик убит, но в конечном итоге адвокат, которого сыграл Уилл Смит, и бунтарь из АНБ, сыгранный Джином Хэкманом, отдали убийц из АНБ в руки правосудия. В обоих фильмах АНБ изображается более зловещей, чем ЦРУ, и во многом АНБ унаследовала роль этого ведомства, несущего угрозу.</p></li>
</ul>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://bege13mot.github.io/post/travis-ci/">Переезд на Travis-CI</a>
      </h1>
      <span class="post-date">May 4, 2017 &nbsp;  &nbsp; <a href="https://bege13mot.github.io/post/travis-ci/#disqus_thread">Comments</a>
      </span>
      <p>
            
      <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
      
      
      Tag:      
      <a class="label" href="https://bege13mot.github.io/tags/tech">tech</a><a class="label" href="https://bege13mot.github.io/tags/it">it</a>
      </p>
      
      <p>Когда я только переехал на Hugo, встал вопрос об автоматизации обновления сайта. Не стал ничего выдумывать и просто следовал рекомендациям на офицальном сайте <a href="https://gohugo.io/tutorials/automated-deployments/">gohugo.io</a> и настроил <a href="https://app.wercker.com/">Wercker</a>. Все отлично работало.</p>

<p>Но однажды сборка сломалась - оказалось в образе <em>debian</em> перестал работать <em>wget</em>. Пришлось немного поправить настройки. В итоге получилось следующее (определенно избыточно):</p>

<pre><code>box: debian
build:
  steps:
    - script:
        name: install git
        code: |
          apt-get update &amp;&amp; apt-get install git -y
    - script:
        name: initialize git submodules
        code: |
            git submodule update --init --recursive
    - arjen/hugo-build@1.16.1
deploy:  
  steps:
    - script:
        name: install git
        code: |
          apt-get update &amp;&amp; apt-get install git -y
    - lukevivier/gh-pages@0.2.1:
        token: $GIT_TOKEN
        repo: Bege13mot/Bege13mot.github.io
        basedir: public
</code></pre>

<p>Время шло, Wercker исправно работал. Но тут его купил Oracle, о чем красноречиво напоминала красная плашка на всех страницах. Может быть, ничего страшного и не случится, но на всякий случай надо подготовить запасной вариант.</p>

<p>Блог хостится на Github, и первая CI, что приходит на ум, конечно <a href="https://travis-ci.org">Travis</a>. Благо и инструкций для этого есть немало. Я использовал <a href="http://www.tutysara.net/posts/2016/09/27/automating-hugo-blog-deployment-to-github-pages-using-travis-ci/">вот эту</a>.</p>

<p>Единственное что, немного доработал <em>deploy.sh</em>, чтобы деплоить только если есть изменения. Иначе даже при добавлении черновика блог будет пересобираться. За основу взял <a href="https://gist.github.com/domenic/ec8b0fc8ab45f39403dd">статью</a>. Итоговый результат:</p>

<pre><code># !/bin/bash
set -e # Exit with nonzero exit code if anything fails

SOURCE_BRANCH=&quot;master&quot;

# Pull requests and commits to other branches shouldn't try to deploy, just build to verify
if [ &quot;$TRAVIS_PULL_REQUEST&quot; != &quot;false&quot; -o &quot;$TRAVIS_BRANCH&quot; != &quot;$SOURCE_BRANCH&quot; ]; then
    echo &quot;Skipping deploy; just doing a build.&quot;    
    exit 0
fi

# Save some useful information
REPO=&quot;bege13mot.github.io&quot;
GH_REPO=&quot;github.com/bege13mot/$REPO.git&quot;
#SHA=`git rev-parse --verify HEAD`
EMAIL=&quot;bege13mot@gmail.com&quot;

# Build the project.
hugo # if using a theme, replace by 'hugo -t &lt;yourtheme&gt;'

# Clone the existing gh-pages for this repo into out/
git clone --depth=1 &quot;https://$GH_REPO&quot; out

# Clean out existing contents
rm -rf out/**/* || exit 0

# copy files to commit
cp -R public/* out

# Now let's go have some fun with the cloned repo
cd out
git remote
git config user.name &quot;Travis CI&quot;
git config user.email &quot;$EMAIL&quot;

# If there are no changes to the compiled out (e.g. this is a README update) then just bail.
git status
if git diff-index --quiet HEAD --; then
    echo &quot;No changes to the output on this push; exiting.&quot;
    exit 0
fi

# Commit the &quot;changes&quot;, i.e. the new version.
# The delta will show diffs between new and old versions.
git add -A .
git commit -m &quot;Deploy to GitHub Pages&quot;

# Now that we're all set up, we can push.
git push &quot;https://$GH_TOKEN@$GH_REPO&quot; $SOURCE_BRANCH
</code></pre>

<p>Переезд на более &ldquo;стабильный&rdquo; (как минимум более известный и проверенный) CI успешно состоялся. Заодно и процесс деплоя упростился после отказа от сторонних скриптов.</p>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://bege13mot.github.io/post/demonkeeping/">Практическое демоноводство, Кристофер Мур</a>
      </h1>
      <span class="post-date">May 1, 2017 &nbsp;  &nbsp; <a href="https://bege13mot.github.io/post/demonkeeping/#disqus_thread">Comments</a>
      </span>
      <p>
            
      <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
      
      
      Tag:      
      <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/fiction">fiction</a>
      </p>
      
      <p><img src="/img/2017/demonkeeping.jpg" alt="image" /></p>

<p>Также смешно как и <a href="https://bege13mot.github.io/post/lust-lizard/">Ящер страсти из бухты грусти</a>, юмор все также черен, люди все также безумны. Вместо психоаналитиков жертвой сатиры стала религия. Очень приятно читать, но Мура мне пожалуй хватит. Эти две книги в одном стиле, но &ldquo;ящер&rdquo; понравился больше.</p>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://bege13mot.github.io/post/thinking-java/">Thinking in Java by Bruce Eckel</a>
      </h1>
      <span class="post-date">Apr 29, 2017 &nbsp;  &nbsp; <a href="https://bege13mot.github.io/post/thinking-java/#disqus_thread">Comments</a>
      </span>
      <p>
            
      <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
      
      
      Tag:      
      <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/it">it</a><a class="label" href="https://bege13mot.github.io/tags/tech">tech</a>
      </p>
      
      

<p><img src="/img/2017/thinking-java.jpg" alt="image" /></p>

<p>Как же долго я читал эту книгу, года три, не меньше. Разные заходы, на разных языках. И наконец дочитал.</p>

<p>Поэтому это обычная рецензия с краткими заметками. Множество людей уже до меня ее прочитали, разобрали и законспектировали. Оставлю маленькое напоминание о том, как сложно это было. Надо бы повторить.</p>

<h4 id="заметки">Заметки:</h4>

<ul>
<li><p>finalize()  - вызывается только в процессе garbage collection. Т.е может так и не быть вызванным. Его полезно использовать например для обьектов, что открывают файлы - перед уничтожением обьекта файл должен быть закрыт.</p></li>

<li><p>A package contains a group of classes, organized together under a single namespace.</p></li>

<li><p>When you compile a .java file, you get an output file for each class in the .java file. Each
output file has the name of a class in the .java file, but with an extension of .class. Thus you
can end up with quite a few .class files from a small number of .java files.</p></li>

<li><p>The private keyword means that no one can access that member except the class that
contains that member, inside methods of that class. Other classes in the same package cannot
access private members, so it’s as if you’re even insulating the class against yourself.</p></li>

<li><p>The trick is to use the classes without soiling the existing code. In this chapter you’ll see two
ways to accomplish this. The first is quite straightforward: you simply create objects of your
existing class inside the new class. This is called composition, because the new class is
composed of objects of existing classes. You’re simply reusing the functionality of the code,
not its form.</p></li>

<li><p>The second approach is more subtle. It creates a new class as a type of an existing class. You
literally take the form of the existing class and add code to it without modifying the existing
class. This technique is called inheritance, and the compiler does most of the work.
Inheritance is one of the cornerstones of object-oriented programming, and has additional
implications that will be explored in the Polymorphism chapter.</p></li>

<li><p>A third relationship, which is not directly supported by Java, is called delegation. This is
midway between inheritance and composition, because you place a member object in the
class you’re building (like composition), but at the same time you expose all the methods
from the member object in your new class (like inheritance)</p></li>

<li><p>Wouldn’t it be much nicer if you could just write a single method that takes the base class as
its argument, and not any of the specific derived classes? That is, wouldn’t it be nice if you
could forget that there are derived classes, and write your code to talk only to the base class?
That’s exactly what polymorphism allows you to do. However, most programmers who come
from a procedural programming background have a bit of trouble with the way
polymorphism works.</p></li>

<li><p>Once you learn about polymorphism, you can begin to think that everything happens
polymorphically. However, only ordinary method calls can be polymorphic. For example, if
you access a field directly, that access will be resolved at compile time</p></li>

<li><p>If a method is static, it doesn’t behave polymorphically. Static methods are associated with the class, and not the individual objects.</p></li>

<li><p>Each inner class can independently inherit from an implementation. Thus, the inner
class is not limited by whether the outer class is already inheriting from an
implementation.
Without the ability that inner classes provide to inherit—in effect—from more than one
concrete or abstract class, some design and programming problems would be intractable.
So one way to look at the inner class is as the rest of the solution of the multiple-inheritance
problem. Interfaces solve part of the problem, but inner classes effectively allow &ldquo;multiple
implementation inheritance.&rdquo; That is, inner classes effectively allow you to inherit from more
than one non-interface.</p></li>

<li><p>The Java container library takes the idea of &ldquo;holding your objects&rdquo; and divides it into two
distinct concepts, expressed as the basic interfaces of the library:</p>

<ul>
<li>Collection: a sequence of individual elements with one or more rules applied to
them. A List must hold the elements in the way that they were inserted, a Set cannot
have duplicate elements, and a Queue produces the elements in the order
determined by a queuing discipline (usually the same order in which they are
inserted).</li>
<li>Map: a group of key-value object pairs, allowing you to look up a value using a key.
An ArrayList allows you to look up an object using a number, so in a sense it
associates numbers to objects. A map allows you to look up an object using another
object. It’s also called an associative array, because it associates objects with other
objects, or a dictionary, because you look up a value object using a key object just like
you look up a definition using a word. Maps are powerful programming tools.</li>
</ul></li>

<li><p>There are two types of List:</p>

<ul>
<li>The basic ArrayList, which excels at randomly accessing elements, but is slower
when inserting and removing elements in the middle of a List.</li>
<li>The LinkedList, which provides optimal sequential access, with inexpensive
insertions and deletions from the middle of the List. A LinkedList is relatively slow
for random access, but it has a larger feature set than the ArrayList.</li>
</ul></li>

<li><p>One solution is what I call the Adapter Method idiom. The &ldquo;Adapter&rdquo; part comes from design
patterns, because you must provide a particular interface to satisfy the foreach statement.
When you have one interface and you need another one, writing an adapter solves the
problem. Here, I want to add the ability to produce a reverse iterator to the default forward
iterator, so I can’t override. Instead, I add a method that produces an Iterable object which
can then be used in the foreach statement. As you see here, this allows us to provide multiple
ways to use foreach:</p></li>

<li><p>Exception handling, two methods -  Termination vs. resumption</p></li>

<li><p>Exception guidelines
Use exceptions to:</p>

<ol>
<li>Handle problems at the appropriate level. (Avoid catching exceptions unless you know
what to do with them.)</li>
<li>Fix the problem and call the method that caused the exception again.</li>
<li>Patch things up and continue without retrying the method.</li>
<li>Calculate some alternative result instead of what the method was supposed to
produce.</li>
<li>Do whatever you can in the current context and rethrow the same exception to a
higher context.</li>
<li>Do whatever you can in the current context and throw a different exception to a higher
context.</li>
<li>Terminate the program.</li>
<li>Simplify. (If your exception scheme makes things more complicated, then it is painful
and annoying to use.)</li>
<li>Make your library and program safer. (This is a short-term investment for debugging,
and a long-term investment for application robustness.)</li>
</ol></li>
</ul>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://bege13mot.github.io/post/lust-lizard/">Ящер страсти из бухты грусти, Кристофер Мур</a>
      </h1>
      <span class="post-date">Apr 23, 2017 &nbsp;  &nbsp; <a href="https://bege13mot.github.io/post/lust-lizard/#disqus_thread">Comments</a>
      </span>
      <p>
            
      <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
      
      
      Tag:      
      <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/fiction">fiction</a>
      </p>
      
      <p><img src="/img/2017/lust-lizard.jpg" alt="image" /></p>

<p>Спасибо медузе за <a href="https://meduza.io/feature/2017/04/01/sem-smeshnyh-knig-kotorye-vy-ne-chitali-ili-zabyli-i-bonus">подборку книг</a> на первое апреля. Самому догадаться, что скрывается за этим, хмм.. странным, называнием трудно.</p>

<p>А между прочим название очень точно отражает происходящее. И ящер, весьма страстный, и бухта, с морем грусти, присутствуют. Присутствуют еще разнообразные горожане, от барменов до ученых, со своими &ldquo;тараканами&rdquo;, ирония, черный юмор и пародия почти на все, что есть в современном городе. Сказка, а не книга. Понравилось.</p>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://bege13mot.github.io/post/top-down-approach/">Компьютерные сети. Нисходящий подход, Джеймс Куроуз, Кит Росс</a>
      </h1>
      <span class="post-date">Apr 16, 2017 &nbsp;  &nbsp; <a href="https://bege13mot.github.io/post/top-down-approach/#disqus_thread">Comments</a>
      </span>
      <p>
            
      <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
      
      
      Tag:      
      <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/theory">theory</a><a class="label" href="https://bege13mot.github.io/tags/it">it</a>
      </p>
      
      

<p><img src="/img/2017/cn-top-down.jpg" alt="image" /></p>

<p>Пожалуй, идеальная книга для знакомства с сетями. В отличие от <a href="https://bege13mot.github.io/post/компьютерные-сети-эндрю-таненбаум/">Компьютерных сетей, Эндрю Таненбаума</a>, здесь упор на практические примеры. Зачем это нужно, как оно помогает решать конкретную задачу. И почти никой теории, в отличии от Таненбаума. Что как раз прекрасно подходит для новичков. А еще в книге есть великолепная глава о том, что происходит при наборе google.com в браузере с точки зрения сети. Со всеми подробностями.</p>

<h4 id="заметки">Заметки:</h4>

<ul>
<li><p>В контексте IP-протокола принято говорить, что подобная сеть, соединяющая три интерфейса хост-машин и один интерфейс маршрутизатора, представляет собой подсеть. В технической литературе по Интернету подсеть также иногда называется IP-сеть или просто сеть. В ходе IP- адресации данной подсети присваивается адрес 223.1.1.0/24. Часть адреса /24, иногда называемая маской подсети, указывает, что 24 крайних левых разряда 32-разрядного значения определяют адрес подсети. Соответственно, подсеть 223.1.1.0/24 состоит из трех интерфейсов хостов (223.1.1.1, 223.1.1.2 и 223.1.1.3) и одного интерфейса маршрутизатора (223.1.1.4). Любые дополнительные хосты, подключаемые к подсети 223.1.1.0/24, обязательно должны будут иметь адреса вида 223.1.1.xxx.</p></li>

<li><p>При передаче дейтаграмм используются и адреса сетевого уровня (например, IP-адреса Интернета), и адреса канального уровня (то есть MAC-адреса), поэтому возникает потребность в преобразовании одних адресов в другие. В Интернете эту работу выполняет протокол разрешения адресов (Address Resolution Protocol, ARP)&hellip; Итак, ARP-модуль преобразует IP-адрес в MAC-адрес узла. Во многом это аналогично системе DNS, преобразующей имена хостов в IP-адреса.</p></li>

<li><p>Ретроспектива: один день из жизни запроса веб-страницы</p>

<ul>
<li>

<ul>
<li><strong>Начало: DHCP, UDP, IP и Ethernet</strong></li>
</ul></li>
</ul>

<ol>
<li><p>Операционная система на ноутбуке Боба создает сообщение с запросом DHCP и записывает это сообщение в UDP-сегмент. В качестве порта получателя указывается порт 67 (DHCP-сервер), а порт отправителя имеет номер 68 (DHCP-клиент). После этого UDP-сегмент записывается в IP дейтаграмму с широковещательным IP-адресом получателя (255.255.255.255). IP-адрес отправителя будет равен 0.0.0.0, так как у ноутбука Боба еще нет IP-адреса.</p></li>

<li><p>IP-дейтаграмма, содержащая сообщение с запросом DHCP, затем помещается в Ethernet-кадр. Ethernet-кадр обладает MAC- адресами назначения FF:FF:FF:FF:FF:FF, поэтому кадр будет широковещательно передаваться всем устройствам, подключенным к коммутатору (остается надеяться, что среди этих устройств окажется и DHCP-сервер). Исходный MAC-адрес кадра совпадает с адресом ноутбука Боба, 00:16:D3:23:68:8A.</p></li>

<li><p>Широковещательный Ethernet-кадр, содержащий DHCP-запрос — это первый кадр, отправленный ноутбуком Боба на Ethernet- коммутатор. Коммутатор широковещательно передает этот входящий кадр на все свои выходные порты, в том числе на порт, подключенный к маршрутизатору.</p></li>

<li><p>Маршрутизатор получает широковещательный Ethernet-кадр с DHCP- запросом на интерфейс с MAC-адресом 00:22:6B:45:1F:1B, после чего IP-дейтаграмма извлекается из Ethernet-кадра. Широковещательный IP-адрес назначения дейтаграммы указывает, что IP-дейтаграмма должна быть обработана на данном узле более высокоуровневыми протоколами, поэтому полезная нагрузка дейтаграммы (UDP-сегмент) демультиплексируется вплоть до UDP, а сообщение с запросом DHCP извлекается из UDP-сегмента. Итак, теперь у DHCP-сервера есть сообщение с запросом DHCP.</p></li>

<li><p>Предположим, что DHCP-сервер, работающий на маршрутизаторе, может выделять адреса из блока CIDR 68.85.2.0/24. Таким образом, в данном примере все IP-адреса университета будут относиться к блоку адресов провайдера Comcast. Далее допустим, что DHCP-сервер выделяет ноутбуку Боба адрес 65.85.2.101. DHCP-сервер создает сообщение DHCP ACK, в котором содержится этот IP-адрес, а также следующая информация: IP-адрес DNS-сервера (68.87.71.226), IP-адрес шлюзового маршрутизатора, задаваемого по умолчанию (68.85.2.1) и, наконец, блок подсети (65.85.2.0/24), он же — «маска сети». DHCP-сообщение записывается в UDP-сегмент, который заключается в IP-дейтаграмму, а она, в свою очередь — в Ethernet-кадр. Ethernet-кадр располагает исходным MAC-адресом (это адрес интерфейса маршрутизатора, соединяющего маршрутизатор с домашней сетью — 00:22:6B:45:1F:1B) и конечным MAC-адресом (это адрес ноутбука Боба 00:16:D3:23:68:8A).</p></li>

<li><p>Ethernet-кадр, содержащий сообщение DHCP ACK (одноадресно), передается маршрутизатором на коммутатор. Поскольку коммутатор является самообучающимся, а ранее получил Ethernet-кадр (с DHCP-запросом) с ноутбука Боба, коммутатору уже известно, что кадр, идущий на адрес 00:16:D3:23:68:8A, нужно просто передать на выходной порт, ведущий к ноутбуку Боба.</p></li>

<li><p>Ноутбук Боба получает сообщение DHCP ACK, извлекает IP-дейтаграмму из Ethernet-кадра, затем UDP-сегмент из IP-дейтаграммы, после чего — сообщение DHCP ACK из UDP-сегмента. Затем DHCP-клиент с ноутбука Боба записывает его IP-адрес, а также IP-адрес его DNS-сервера. Кроме того, он заносит адрес в свою IP- таблицу маршрутизации. Ноутбук Боба будет отсылать на заданный по умолчанию шлюз все дейтаграммы, чей адрес назначения находится вне его подсети 68.85.2.0/24. На данном этапе ноутбук Боба уже инициализировал свои сетевые компоненты и готов обрабатывать операции выборки веб-страниц.</p>

<ul>
<li><strong>Начало продолжается: DNS и ARP</strong></li>
</ul></li>

<li><p>Когда Боб вводит в браузер адрес www.google.com, начинается длинная цепочка событий. Ее конечный результат — отображение главной страницы Google в браузере. Для этого операционная система на ноутбуке Боба создает сообщение с запросом DNS, помещая строку «www.google.com» в тот раздел DNS-сообщения, где содержится запрос. Затем это DNS-сообщение записывается в UDP-сегмент с портом назначения 53 (это DNS-сервер). После этого данный UDP-сегмент помещается в IP-дейтаграмму, имеющую IP-адрес получателя 68.87.71.226 (это адрес DNS-сервера, который мы приняли в возвращенном сообщении DHCP ACK на этапе 5) и IP-адрес отправителя 68.85.2.101.</p></li>

<li><p>После этого ноутбук Боба помещает дейтаграмму, содержащую сообщение с запросом DNS, в Ethernet-кадр. Этот кадр будет отправлен (адресован на сетевом уровне) на шлюзовой маршрутизатор сети того университета, где учится Боб. Однако, хотя ноутбуку Боба и известен IP-адрес шлюзового маршрутизатора университета (65.85.2.1) — эта информация была получена в сообщении DHCP ACK на этапе 5, описанном выше, ему не известен MAC-адрес этого шлюза. Чтобы получить MAC-адрес шлюзового маршрутизатора, на ноутбуке Боба понадобится задействовать протокол ARP.</p></li>

<li><p>Ноутбук Боба создает сообщение с запросом ARP, где указывается целевой IP-адрес 68.85.2.1 (адрес шлюзового маршрутизатора). ARP-сообщение помещается в Ethernet-кадр с широковещательным адресом получателя (FF:FF:FF:FF:FF:FF), после чего ноутбук отправляет Ethernet-кадр на коммутатор, который, в свою очередь, доставляет этот кадр на все подключенные к нему устройства, в том числе на шлюзовой маршрутизатор.</p></li>

<li><p>Шлюзовой маршрутизатор получает кадр с сообщением c ARPзапросом на интерфейс, ведущий в него из университетской сети, и определяет, что целевой IP-адрес 68.85.2.1 в ARP-сообщении совпадает с IP-адресом его интерфейса. После этого шлюзовой маршрутизатор подготавливает ARP-ответ, указывая, что его MAC-адрес 00:22:6B:45:1F:1B соответствует IP-адресу 68.85.2.1. Сообщение с ARP-ответом записывается в Ethernet-кадр с адресом получателя (это ноутбук Боба). После этого кадр отправляется на коммутатор, который доставляет его на ноутбук Боба.</p></li>

<li><p>Ноутбук Боба получает кадр с ответным ARP-сообщением и извлекает MAC-адрес шлюзового маршрутизатора (00:22:6B:45:1F:1B) из этого сообщения.</p></li>

<li><p>Теперь ноутбук Боба (наконец-то!) может отправить Ethernet-кадр с DNS-запросом на MAC-адрес шлюзового маршрутизатора. Обратите внимание: IP-дейтаграмма в этом кадре имеет IP-адрес получателя 68.87.71.226 (это адрес DNS-сервера), тогда как адрес получателя кадра — 00:22:6B:45:1F:1B (это шлюзовой маршрутизатор). Ноутбук Боба отправляет кадр на коммутатор, который, в свою очередь, доставляет этот кадр на шлюзовой маршрутизатор.</p>

<ul>
<li><strong>Начало продолжается: внутридоменная маршрутизация на DNS-сервер</strong></li>
</ul></li>

<li><p>Шлюзовой маршрутизатор получает кадр и извлекает из него IP- дейтаграмму, содержащую DNS-запрос. Маршрутизатор уточняет адрес назначения этой дейтаграммы (68.87.71.226) и определяет по своей таблице маршрутизации, что дейтаграмма должна быть отправлена на маршрутизатор сети Comcast. IP-дейтаграмма помещается в кадре канального уровня для перемещения по каналу, который связывает университетский маршрутизатор с маршрутизатором Comcast. Кадр отправляется по этому каналу.</p></li>

<li><p>Вышеупомянутый маршрутизатор из сети Comcast получает кадр, извлекает IP-дейтаграмму, проверяет ее адрес получателя (68.87.71.226), а потом по своей таблице маршрутизации определяет выходной интерфейс, через который этот кадр должен быть отправлен на DNS-сервер. Таблица маршрутизации была заполнена при помощи протокола внутридоменной маршрутизации сети Comcast (это может быть протокол RIP, OSPF или IS-IS), а также с применением протокола BGP, обеспечивающего междоменную маршрутизацию в Интернете.</p></li>

<li><p>Наконец, IP-дейтаграмма, содержащая DNS-запрос, прибывает на DNS-сервер. DNS-сервер извлекает сообщение с DNS-запросом, ищет в своей базе данных DNS адрес www.google.com, после чего находит запись DNS-ресурса, содержащую IP-адрес (64.233.169.105) сайта www.google.com (предполагается, что эта запись уже кэширована на DNS-сервере). Как вы помните, эти кэшированные данные берутся с авторитетного DNS-сервера, отвечающего за сайт google.com. Сервер формирует ответное DNS-сообщение, в котором содержится отображение данного хост-имени на соответствующий IP-адрес, и помещает это ответное сообщение в UDP-сегмент. Сегмент, находящийся в IP-дейтаграмме, адресуется на ноутбук Боба (68.85.2.101). Эта дейтаграмма будет отправлена обратно в сеть Comcast, а оттуда далее, через Ethernet-коммутатор на ноутбук Боба.</p></li>

<li><p>Ноутбук Боба извлекает IP-адрес сервера www.google.com из DNS-сообщения. Наконец, проделав всю эту огромную работу, ноутбук Боба готов подключиться к серверу www.google.com!</p>

<ul>
<li><strong>Клиент-серверное взаимодействие: TCP и HTTP</strong></li>
</ul></li>

<li><p>Теперь, когда ноутбук Боба обладает IP-адресом www.google.com, он может создать TCP-сокет, который будет использоваться для отправки сообщения HTTP GET на сайт www. google.com. Когда Боб создает TCP-сокет, протокол TCP в ноутбуке Боба сперва должен выполнить тройное рукопожатие с протоколом TCP на www.google.com. Поэтому для начала ноутбук Боба создает сегмент TCP SYN с портом назначения 80 (для HTTP), помещает TCP-сегмент в IP-дейтаграмме, задавая IP-адрес получателя 64.233.169.105 (www.google.com). Эта дейтаграмма помещается в кадр с MAC-адресом получателя 00:22:6B:45:1F:1B (шлюзовой маршрутизатор). После всех этих операций кадр отправляется на коммутатор.</p></li>

<li><p>Маршрутизаторы из университетской сети, сети Comcast и сети Google шлют дейтаграмму с пакетом TCP SYN на адрес www.google. com. Для этого используются таблицы маршрутизации каждого из них, как описано выше в шагах 14-16. Как вы помните, записи в таблицах маршрутизации, управляющие перемещением пакетов по междоменным связям между сетями Comcast и Google, формируются протоколом BGP.</p></li>

<li><p>Наконец, дейтаграмма с пакетом TCP SYN прибывает на www. google.com. Там сообщение TCP SYN извлекается из дейтаграммы и демультиплексируется на нужный сокет, ассоциированный с портом 80. Специальный сокет соединения создается для установления соединения между HTTP-сервером Google и ноутбуком Боба по протоколу TCP. Генерируется сегмент TCP SYNACK, затем этот сегмент помещается в дейтаграмме, адресованной на ноутбук Боба, и, наконец, заключается в кадре канального уровня, подходящем для передачи по каналу, соединяющему www. google.com и его первый транзитный маршрутизатор.</p></li>

<li><p>Дейтаграмма, содержащая сегмент TCP SYNACK, направляется через сети Google, Comcast и университета, в итоге оказываясь на сетевой Ethernet-карте ноутбука Боба. Дейтаграмма демультиплексируется в операционной системе на TCP-сокет, созданный в шаге 18, и этот сокет переходит в соединенное состояние.</p></li>

<li><p>Когда сокет на ноутбуке Боба (наконец-то!) готов отправлять байты на www.google.com, браузер на ноутбуке создает сообщение с запросом HTTP GET, содержащее адрес URL, откуда требуется взять данные. Затем сообщение HTTP GET записывается на сокет, причем запрос GET становится полезным содержимым TCPсегмента. TCP-сегмент помещается в дейтаграмму, отправляется и доставляется на сайт www.google.com, как описано в шагах 18–20 выше.</p></li>

<li><p>HTTP-сервер по адресу www.google.com считывает сообщение HTTP GET с TCP-сокета, создает HTTP-ответ (раздел 2.2), помещает контент запрошенной веб-страницы в тело ответного HTTP-сообщения, после чего отправляет это сообщение на TCP-сокет.</p></li>

<li><p>Дейтаграмма, содержащая HTTP-ответ, направляется через сети Google, Comcast и университетскую сеть, после чего прибывает на ноутбук Боба. Браузер на ноутбуке считывает HTTP-сообщение с сокета, извлекает html-код веб-страницы из тела HTTP-ответа и (наконец-то!) отображает веб-страницу.</p></li>
</ol></li>

<li><p>Чтобы решить проблему доставки огромных потоков данных пользователям из разных стран, почти все крупные компании используют сети распространения контента (Content Distribution Network, CDN). Сеть CDN состоит из множества размещенных в разных местах серверов, в которых хранятся видеофайлы (и другие веб-ресурсы, такие как документы, изображения и аудиоданные); каждый пользователь перенаправляется в ту точку сети, которая является для него наиболее подходящей. CDN может принадлежать одной компании, предоставляющей данные (как в случае с компанией Google, которая распространяет видеоролики и другие данные через сервис YouTube), или использоваться сразу нескольки- ми провайдерами (например, компания Akamai предоставляет CDN для многих сервисов, в том числе для Netflix и Hulu)&hellip; Большинство сетей CDN выполняют перехват и перенаправление на уровне DNS.</p></li>

<li><p>Важная область практического применения цифровых подписей — это сертификация с открытым ключом. Такая сертификация удостоверяет, что открытый ключ принадлежит конкретному лицу.Сертификация с открытым ключом применяется во многих популярных сетевых протоколах — в частности, в IPsec и SSL.</p></li>

<li><p>Чтобы решить проблему неэффективности, будем использовать сеансовый ключ. Во-первых, Алиса случайным образом выбирает симметричный сеансовый ключ KS, во-вторых, зашифровывает этим ключом KS свое сообщение m, в-третьих, зашифровывает сеансовый ключ KS открытым ключом Боба K+B, в-четвертых, формирует из всех зашифрованных данных один пакет и, в-пятых, посылает этот пакет по адресу электронной почты Боба. Получив сообщение, Боб, во-первых, с помощью своего закрытого ключа K–B получает сеансовый ключ KS, во-вторых, с помощью сеансового ключа сеанса KS расшифровывает сообщение m.</p></li>
</ul>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://bege13mot.github.io/post/start-with-no/">Сначала скажите &#39;НЕТ&#39;. Секреты профессиональных переговорщиков, Джим Кэмп</a>
      </h1>
      <span class="post-date">Mar 21, 2017 &nbsp;  &nbsp; <a href="https://bege13mot.github.io/post/start-with-no/#disqus_thread">Comments</a>
      </span>
      <p>
            
      <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
      
      
      Tag:      
      <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/psychology">psychology</a><a class="label" href="https://bege13mot.github.io/tags/non-fiction">non-fiction</a>
      </p>
      
      

<p><img src="/img/2017/start-with-no.jpg" alt="image" /></p>

<p>Эту книгу советуют чуть ли не в каждом посте о &ldquo;бюро Артёма Горбунова&rdquo;. Её и ещё &ldquo;Пиши, сокращай&rdquo;. На удивление понравилось.</p>

<p>Почему на удивление? Я видел два типа книг о переговорах. Одни больше про психологию, о сбоях, что дает наш логический аппарат и как этим пользуются. Например, &ldquo;Психология влияния&rdquo; Чалдини. Другие, про практический опыт переговоров и хитрые трюки. Например, &ldquo;Договориться можно обо всем!&rdquo; Кеннеди. Эти, с трюками, книги и статьи не чураются применять собственные приемы на читателях. Множественно повторение одного и того же, &ldquo;вывернутые&rdquo; причинно-следственные связи, освещение только одной стороны вопроса и т.д. Несомненно, полезно прочитать об этом один раз, не более.</p>

<p>На первый взгляд, Кэмп должен относиться ко второй категории. Он использует все те же трюки с повторением, однобокое освещение вопросов, одно только постоянное упоминание модели переговоров &ldquo;win-win&rdquo; чего стоит. Но так делают многие &ldquo;американские&rdquo; авторы. А в методике Кэмпа минимум трюков, максимум подготовки, уважение к оппоненту, некий &ldquo;стоицизм&rdquo; - отказывайтесь от всего ненужного, ожидайте худшего. Весьма полезная книга.</p>

<h4 id="заметки">Заметки:</h4>

<ul>
<li>Любые переговоры — это соглашение между двумя или более сторонами, в котором каждая из сторон имеет право вето — право сказать «нет».</li>
<li>Никогда, ни при каких обстоятельствах не «рассыпайте бобы» за столом переговоров или где угодно еще.</li>
<li>Никогда не начинайте переговоров — никогда не делайте даже телефонного звонка — без соответствующего плана или заранее подготовленного «регламента».</li>
<li>Единственные адекватные цели — те, которыми вы можете управлять: ваше собственное поведение и действия.</li>
<li>Наша миссия должна обращаться к миру противника; наш мир должен оставаться на втором плане.</li>
<li>Расходуйте как можно больше времени на действия, которые «оплачиваются», и как можно меньше — на те, которые «не оплачиваются».</li>
<li>Вы ни в чем не нуждаетесь. Вы просто чего-то хотите.</li>
<li>Никогда не спасайте противника. Спасти противника невозможно.</li>
<li>Только один человек на переговорах может чувствовать себя «в порядке». И этот человек — ваш противник.</li>
<li>Все действия — все решения — начинаются с видения. Без видения они невозможны.</li>
<li>Всегда демонстрируйте уважение «блокатору».</li>
<li>Все соглашения необходимо прояснить пункт за пунктом и проговорить трижды (при помощи техники «3 +»).</li>
<li>Чем яснее видна боль, тем проще процесс принятия решения.</li>
<li>Ценность переговоров растет по мере увеличения потраченных на них времени, энергии, денег и эмоций.</li>
<li>Избегайте пустых разговоров.</li>
<li>Всегда давайте противнику возможность сохранить лицо.</li>
<li>Самая замечательная презентация, которую вы можете сделать, — та, которой ваш противник никогда не увидит.</li>
<li>Переговоры заканчиваются только тогда, когда мы хотим их закончить.</li>
<li>«Нет» — хорошо, «да» — плохо, «может быть» — хуже всего.</li>
<li>Научитесь описывать боль.</li>
<li>Миссия управляет всем.</li>
<li>Решения эмоциональны на сто процентов.</li>
<li>Открытые вопросы способствуют формированию видения.</li>
<li>Проявляйте заботу.</li>
<li>Ничего не предполагайте. Ничего не ожидайте. Освободите свое сознание.</li>
<li>Кто на самом деле принимает решения? Вы знаете всех этих людей?</li>

<li><p>Платите вперед.</p></li>

<li><p>Я настоятельно прошу вас начать вести ежедневный отчет, дневник, в котором вы спрашиваете себя, как часто и насколько эффективно вы контролировали свои потребности, были «не в порядке», говорили «нет» и поощряли отказы, заботились о противнике, использовали контрвопросы, технику «3 +» и «связки», задавали открытые вопросы, делали записи, приняли к сведению неудачное решение противника.</p></li>

<li><p>Миссия должна быть адекватной. Что такое адекватная миссия? Прежде всего, она должна обращаться к миру противника.
Вы, конечно, можете спросить: если это — моя миссия, зачем же мне концентрироваться на ком-то другом? Затем что, если только вы не живете в полном одиночестве на необитаемом острове, ваша миссия состоит в том, чтобы концентрироваться на ком-то другом. Этот другой — основа вашей жизни, являетесь ли вы политическим деятелем, врачом, пациентом, бизнесменом или участником переговоров. Никогда не забывайте об этом.</p></li>

<li><p>Умение задавать хорошие вопросы — самое качественное наше «горючее». Это — основная поведенческая цель. Остальные четыре из пяти других поведенческих целей, которые я называю «горючим» системы Кэмпа, оказывают непосредственную поддержку нашим вопросам Они помогают контролировать то, что мы говорим, и использовать свои слова в собственных же интересах. Я называю эти четыре типа приемов так: «забота», «контрвопрос», «связка» и «3 +». Пятый вид «горючего» не связан с вопросами и называется «травить леску».</p></li>

<li><p>Хорошо подготовленная повестка дня или мини-повестка включает пять основных пунктов:
1. Проблемы.
2. Наш эмоциональный багаж.
3. Эмоциональный багаж противника.
4. Чего мы хотим от ситуации.
5. Что произойдет потом.</p></li>

<li><p>Когда цена справедлива, я плачу сполна. Это дает мне силу настаивать на том, чтобы мне тоже платили сполна, когда это справедливо. В этом мире мы обычно получаем то, за что платим. Помните об этом и действуйте, исходя из самых высоких представлений о самом себе.</p></li>
</ul>

      
    </div>
    
    

<ul class="pagination">
    
    <li>
        <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li
    class="disabled">
    <a href="" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
        
        
    
    
    <li
    class="active"><a href="/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li
    ><a href="/page/2/">2</a></li>
    
    
    
    
    
    
        
        
    
    
    <li
    ><a href="/page/3/">3</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="disabled"><span aria-hidden="true">&hellip;</span></li>
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    <li
    ><a href="/page/21/">21</a></li>
    
    
    <li
    >
    <a href="/page/2/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li>
        <a href="/page/21/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "bege13mot";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

<script src="https://bege13mot.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script>
  var _gaq=[['_setAccount','UA-73422311-1'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

</body>
</html>
