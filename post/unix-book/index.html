<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Операционная система UNIX, Андрей Робачевский &nbsp; </title>

  
  <link rel="stylesheet" href="https://bege13mot.github.io/css/poole.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="https://bege13mot.github.io/css/highlight/sunburst.css">
  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://bege13mot.github.io/touch-icon-144-precomposed.png">
  <link href="/icon/fox.png" rel="icon">

  
  
  
  

  <meta name="description" content="">
  <meta name="keywords" content="">
  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
            
        <img src="/icon/fox.png" alt="avatar" title="">    
      
      <h1></h1>
      
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/">Ivan V's Blog</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/about/">About</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/post/">Posts</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/tags/">Tags</a></li>
      
      <li class="sidebar-nav-item"><a href="https://bege13mot.github.io/categories/">Categories</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/Bege13mot"><img src="/icon/github.svg" class="fa"></img></a>
      <a href="https://www.goodreads.com/user/show/5520080-ivan"><img src="/icon/goodreads.svg" class="fa"></img></a>
      <a href="mailto:bege13mot@gmail.com"><img src="/icon/mail.svg" class="fa"></img></a>
      <a href="https://ru.linkedin.com/in/voronchihin"><img src="/icon/linkedin.svg" class="fa"></img></a>      
      <a href="https://bege13mot.github.io/index.xml" type="application/rss+xml"><img src="/icon/rss.svg" class="fa"></img></a>
      </li>
    </ul>

    

  </div>
</div>


<div class="content container">
  <div class="post">
    <h1>Операционная система UNIX, Андрей Робачевский</h1>
    <span class="post-date">Sep 1, 2017 &middot; 5 minute read &middot; <a href="https://bege13mot.github.io/post/unix-book/#disqus_thread">Comments</a>
    </span>
    <p>
        
    <a class="label" href="https://bege13mot.github.io/categories/post">Post</a>
    
    
    Tag:    
    <a class="label" href="https://bege13mot.github.io/tags/book">book</a><a class="label" href="https://bege13mot.github.io/tags/theory">theory</a>
    </p>
    <p><img src="/img/2017/unix-book.jpg" alt="image"></p>
<p>Книга о Unix 1997 года. При это не скажешь что она особенно устарело. Описываются базовые, по-прежнему актуальные, вещи - структура файловой системы, типы процессов, сигналов, подсистема управления процессами, сеть. И все это на русском, очень понятно, с объяснениями и разжёвыванием.</p>
<p>Хороший учебник.</p>
<h4 id="заметки">Заметки:</h4>
<ul>
<li>
<p>В UNIX существуют 6 типов файлов:</p>
<ul>
<li>обычный файл</li>
<li>каталог</li>
<li>специальный файл устройства</li>
<li>именованный канал или FIFO</li>
<li>символическая связь</li>
<li>сокет</li>
</ul>
</li>
<li>
<p>Обычно программой называют совокупность файлов, будь то набор исходных текстов, объектных файлов или собственно выполняемый файл. Для того чтобы программа могла быть запущена на выполнение, операционная система сначала должна создать окружение или среду выполнения задачи, куда относятся ресурсы памяти, возможность доступа к устройствам ввода/вывода и различным системным ресурсам, включая услуги ядра.
Это окружение (среда выполнения задачи) получило название процесса. Мы можем представить процесс как совокупность данных ядра системы, необходимых для описания образа программы в памяти и управления ее выполнением. Мы можем также представить процесс как программу в стадии ее выполнения, поскольку все выполняющиеся программы представлены в UNIX в виде процессов. Процесс состоит из инструкций, выполняемых процессором, данных и информации о выполняемой задаче, такой как размещенная память, открытые файлы и статус процесса.</p>
</li>
<li>
<p>Процесс в UNIX создается системным вызовом fork(). Процесс, сделавший вызов fork() называется родительским, а вновь созданный процесс — дочерним. Новый процесс является точной копией породившего его процесса. Как это ни удивительно, но новый процесс имеет те же инструкции и данные, что и его родитель. Более того, выполнение родительского и дочернего процесса начнется с одной и той же инструкции, следующей за вызовом fork(). Единственно, чем они различаются — это идентификатором процесса PID. Каждый процесс имеет одного родителя, но может иметь несколько дочерних процессов.
Для запуска задачи, т.е. для загрузки новой программы, процесс должен выполнить системный вызов exec(). При этом новый процесс не порождается, а исполняемый код процесса полностью замещается кодом запускаемой программы. Тем не менее окружение новой программы во многом сохраняется, в частности сохраняются значения переменных окружения, назначения стандартных потоков ввода/вывода, вывода сообщений об ошибках, а также приоритет процесса.
В UNIX запуск на выполнение новой программы часто связан с порождением нового процесса, таким образом сначала процесс выполняет вызов fork(), порождая дочерний процесс, который затем выполняет exec(), полностью замещаясь новой программой.</p>
</li>
<li>
<p>Все процессы в UNIX создаются посредством вызова fork(). Запуск на выполнение новых задач осуществляется либо по схеме fork-and-exec, либо с помощью exec(). &ldquo;Прародителем&rdquo; всех процессов является процесс init(1М), называемый также распределителем процессов. Если построить граф &ldquo;родственных отношений&rdquo; между процессами, то получится дерево, корнем которого является init(1M).</p>
</li>
<li>
<p>По умолчанию команда kill() посылает сигнал с номером 15 — SIGTERM, действие по умолчанию для которого — завершение выполнения процесса, получившего сигнал.
Иногда процесс продолжает существовать и после отправления сигнала SIGTERM. В этом случае можно применить более жесткое средство — послать процессу сигнал SIGKILL с номером (9), — поскольку этот сигнал нельзя ни перехватить, ни игнорировать</p>
</li>
<li>
<p>Каждый активный процесс в UNIX имеет уникальный идентификатор процесса, PID. Запуская скрипт, вы порождаете в системе процесс с уникальным PID. Значение PID сохраняется в переменной $$. Эту переменную удобно использовать в названиях временных файлов, поскольку их имена будут уникальными</p>
</li>
<li>
<p>Напомним, что сигналы SIGKILL и SIGSTOP невозможно ни игнорировать, ни перехватить. Сигнал SIGKILL является силовым методом завершения выполнения &ldquo;непослушного&rdquo; процесса, а от работоспособности SIGSTOP зависит функционирование системы управления заданиями.</p>
</li>
<li>
<p>Смысл виртуальной памяти заключается в том, что каждый процесс выполняется в собственном виртуальном адресном пространстве. Виртуальное адресное пространство — настоящий рай для процесса. Во-первых, у процесса создается ощущение исключительности — ведь все адресное пространство принадлежит только ему. Во-вторых, он больше не ограничен объемом физической памяти — виртуальная память может значительно превышать физическую. В результате процессы становятся изолированными друг от друга и не имеют возможности (даже при желании) &ldquo;хозяйничать&rdquo; в адресном пространстве соседа. Физическая память распределяется максимально эффективно — она не зависит от распределения виртуальной памяти отдельного процесса.</p>
</li>
<li>
<p>Можно сказать, что каждый процесс в операционной системе UNIX выполняется на собственной виртуальной вычислительной машине, где все ресурсы принадлежат исключительно данному процессу. Подсистема управления памятью обеспечивает такую иллюзию в отношении физической памяти.</p>
</li>
<li>
<p>Существуют всего три события, при которых выполнение процесса переходит в режим ядра — аппаратные прерывания, особые ситуации и системные вызовы. Во всех случаях ядро UNIX получает управление и вызывает соответствующую системную процедуру для обработки события. Перед вызовом ядро сохраняет состояние прерванного процесса в системном стеке. После завершения обработки, состояние процесса восстанавливается и процесс возвращается в исходный режим выполнения. Чаще всего это режим задачи, но если, например, прерывание возникло, когда процесс уже находился в режиме ядра, после обработки события он останется в этом режиме.</p>
</li>
<li>
<p>Для синхронизации процессов, а точнее, для синхронизации доступа нескольких процессов к разделяемым ресурсам, используются семафоры. Являясь одной из форм IPC, семафоры не предназначены для обмена большими объемами данных, как в случае FIFO или очередей сообщений. Вместо этого, они выполняют функцию, полностью соответствующую своему названию — разрешать или запрещать процессу использование того или иного разделяемого ресурса.</p>
</li>
<li>
<p>Если говорить о производительности IPC, то наиболее быстрым способом передачи данных между неродственными процессами является разделяемая память. Разделяемая память является частью адресного пространства для каждого из взаимодействующих процессов, поэтому чтение и запись в эту область неотличимы, например, от чтения и записи в область собственных данных процесса. Однако при использовании разделяемой памяти необходимо обеспечить синхронизацию процессов.</p>
</li>
<li>
<p>Индексный дескриптор, или inode, содержит информацию о файле, необходимую для обработки данных, т.е. метаданные файла. Каждый файл ассоциирован с одним inode, хотя может иметь несколько имен в файловой системе, каждое из которых указывает на один и тот же inode.Основные поля дискового inode следующие:</p>
<ul>
<li>Тип файла, дополнительные атрибуты выполнения и права доступа.</li>
<li>Число ссылок на файл, т.е. количество имен, которые имеет файл в файловой системе.</li>
<li>Идентификаторы владельца-пользователя и владельца- группы.</li>
<li>Cтарший и младший номера устройства.</li>
<li>Время последнего доступа к файлу.</li>
<li>Время последней модификации.</li>
<li>Время последней модификации inode (кроме модификации полей di_atime, di_mtime).</li>
<li>Массив адресов дисковых блоков хранения данных.</li>
</ul>
</li>
<li>
<p>Поскольку характеристики периферийных устройств значительно различаются, то UNIX использует два основных типа драйверов — символьные и блочные. Как следует из названия, драйверы первого типа обеспечивают обмен сравнительно небольшими объемами данных с устройством, что имеет место при работе, например, с терминалами или принтерами. Драйверы второго типа производят передачу данных блоками, что характерно для дисковых носителей данных. Эти типы драйверов входят в традиционную подсистему ввода/вывода и присутствуют во всех версиях UNIX.</p>
</li>
<li>
<p>Как уже обсуждалось, старший номер устройства адресует драйвер, в то время как младший номер интерпретируется самим драйвером и может использоваться для различных целей. Например, используя различные младшие номера, процесс может получить доступ к разным разделам жесткого диска, обслуживаемого одним драйвером.</p>
</li>
</ul>

  </div>
  <div id="disqus_thread"></div>
</div>


<script type="text/javascript">
var disqus_shortname = "bege13mot";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>



<script type="text/javascript">
    var disqus_shortname = "bege13mot";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script src="https://bege13mot.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script>
  var _gaq=[['_setAccount','UA-73422311-1'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

</body>
</html>

